<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Miquel De Caceres" />

<meta name="date" content="2020-11-05" />

<title>Package overview</title>

<script>// Hide empty <a> tag within highlighted CodeBlock for screen reader accessibility (see https://github.com/jgm/pandoc/issues/6352#issuecomment-626106786) -->
// v0.0.1
// Written by JooYoung Seo (jooyoung@psu.edu) and Atsushi Yasumoto on June 1st, 2020.

document.addEventListener('DOMContentLoaded', function() {
  const codeList = document.getElementsByClassName("sourceCode");
  for (var i = 0; i < codeList.length; i++) {
    var linkList = codeList[i].getElementsByTagName('a');
    for (var j = 0; j < linkList.length; j++) {
      if (linkList[j].innerHTML === "") {
        linkList[j].setAttribute('aria-hidden', 'true');
      }
    }
  }
});
</script>
<style type="text/css">
a.anchor-section {margin-left: 10px; visibility: hidden; color: inherit;}
a.anchor-section::before {content: '#';}
.hasAnchor:hover a.anchor-section {visibility: visible;}
</style>
<script>// Anchor sections v1.0 written by Atsushi Yasumoto on Oct 3rd, 2020.
document.addEventListener('DOMContentLoaded', function() {
  // Do nothing if AnchorJS is used
  if (typeof window.anchors === 'object' && anchors.hasOwnProperty('hasAnchorJSLink')) {
    return;
  }

  const h = document.querySelectorAll('h1, h2, h3, h4, h5, h6');

  // Do nothing if sections are already anchored
  if (Array.from(h).some(x => x.classList.contains('hasAnchor'))) {
    return null;
  }

  // Use section id when pandoc runs with --section-divs
  const section_id = function(x) {
    return ((x.classList.contains('section') || (x.tagName === 'SECTION'))
            ? x.id : '');
  };

  // Add anchors
  h.forEach(function(x) {
    const id = x.id || section_id(x.parentElement);
    if (id === '') {
      return null;
    }
    let anchor = document.createElement('a');
    anchor.href = '#' + id;
    anchor.classList = ['anchor-section'];
    x.classList.add('hasAnchor');
    x.appendChild(anchor);
  });
});
</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Package overview</h1>
<h4 class="author">Miquel De Caceres</h4>
<h4 class="date">2020-11-05</h4>


<div id="TOC">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#data-structures">Data structures</a><ul>
<li><a href="#forest-objects">Forest objects</a></li>
<li><a href="#soil-objects">Soil objects</a></li>
</ul></li>
<li><a href="#dynamic-simulation-functions">Dynamic simulation functions</a><ul>
<li><a href="#water-balance-and-plant-drought-stress">Water balance and plant drought stress</a></li>
<li><a href="#forest-growth">Forest growth</a></li>
<li><a href="#sub-model-functions">Sub-model functions</a></li>
</ul></li>
<li><a href="#static-functions">Static functions</a><ul>
<li><a href="#plant-species-and-stand-attributes">Plant, species and stand attributes</a></li>
<li><a href="#fuel-properties-and-fire-hazard">Fuel properties and fire hazard</a></li>
</ul></li>
</ul>
</div>

<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>Being able to anticipate the impact of global change on forest ecosystems is one of the major environmental challenges in contemporary societies. However, uncertainties in how forests function and practical constraints in how to integrate available information prevent the development of robust and reliable predictive models. Despite the amount of knowledge accumulated about the functioning and dynamics of Mediterranean forests, scientists should make coordinate their efforts to address the challenge of integrating the different global change drivers in a modelling framework useful for research and applications.</p>
<p>The R package <code>medfate</code> has been designed to study the characteristics and simulate functioning and dynamics of Mediterranean forests. Fire and drought impacts are the main environmental drivers covered by the package. Representation of vegetation is not spatially-explicit (i.e. trees or shrubs do not have explicit coordinates within forest stands). This simplified representation is chosen so that package functions can be easily applied to forest plot data from national forest inventories. Since the package intends to facilitate predictions of not only forest functioning but also forest structure and composition, the taxonomic identity of plants is stored, and parameter values need to be provided for each taxonomic entity (but the package could be used with functional groups).</p>
<p>Package vignettes only cover how to run models using the package functions. Complete documentation on the design and formulation of medfate models can be found in the <strong>medfate reference book</strong> at <a href="https://vegmod.ctfc.cat/software/medfate" class="uri">https://vegmod.ctfc.cat/software/medfate</a>.</p>
</div>
<div id="data-structures" class="section level2">
<h2>Data structures</h2>
<div id="forest-objects" class="section level3">
<h3>Forest objects</h3>
<p>Models included in <code>medfate</code> were primarily designed to be ran on <strong>forest inventory plots</strong>. In this kind of data, the vegetation of a sampled area is primarily described in terms of woody plants (trees and shrubs) along with their size and species identity. Forest plots in <code>medfate</code> are assumed to be in a format that follows closely the Spanish national forest inventory. Each forest plot is represented in an object of class <code>forest</code>, a list that contains several elements. Among them, the most important items are two data frames, <code>treeData</code> (for trees) and <code>shrubData</code> for shrubs:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">data</span>(exampleforestMED)</span>
<span id="cb1-2"><a href="#cb1-2"></a>exampleforestMED</span></code></pre></div>
<pre><code>## $ID
## [1] &quot;1&quot;
## 
## $patchsize
## [1] 10000
## 
## $treeData
##   Species   N   DBH Height Z50  Z95
## 1      54 168 37.55    800 750 3000
## 2      68 384 14.60    660 750 3000
## 
## $shrubData
##   Species Cover Height Z50  Z95
## 1      65  3.75     80 300 1500
## 
## $herbCover
## [1] 10
## 
## $herbHeight
## [1] 20
## 
## attr(,&quot;class&quot;)
## [1] &quot;forest&quot; &quot;list&quot;</code></pre>
<p>Trees are expected to be primarily described in terms of species, diameter (DBH) and height, whereas shrubs are described in terms of species, percent cover and mean height. Functions are provided to map variables in user data frames into tables <code>treeData</code> and <code>shrubData</code> (see function <code>forest_mapWoodyTables()</code>).</p>
</div>
<div id="soil-objects" class="section level3">
<h3>Soil objects</h3>
<p>Simulation models in <code>medfate</code> require information on the physical attributes of soil, namely soil depth, texture, bulk density and rock fragment content. Soil physical attributes can be initialized to default values, for a given number of layers, using function <code>defaultSoilParams()</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1"></a>spar =<span class="st"> </span><span class="kw">defaultSoilParams</span>(<span class="dv">2</span>)</span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="kw">print</span>(spar)</span></code></pre></div>
<pre><code>##   widths clay sand om  bd rfc
## 1    300   25   25 NA 1.5  25
## 2    700   25   25 NA 1.5  45</code></pre>
<p>where <code>widths</code> are soil layer widths in mm; <code>clay</code> and <code>sand</code> are the percentage of clay and sand, in percent of dry weight, <code>om</code> stands for organic matter, <code>bd</code> is bulk density (in <span class="math inline">\(g \cdot cm^{-3}\)</span>) and <code>rfc</code> the percentage of rock fragments. Because soil properties vary strongly at fine spatial scales, ideally soil physical attributes should be measured on samples taken at the forest stand to be simulated. For those users lacking such data, soil properties modelled at larger scales are available via soilgrids.org (see function <code>soilgridsParams()</code>).</p>
<p>The soil input for simulations is an object of class <code>soil</code> (a list) that is created using a function with the same name:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1"></a>examplesoil =<span class="st"> </span><span class="kw">soil</span>(spar)</span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="kw">names</span>(examplesoil)</span></code></pre></div>
<pre><code>##  [1] &quot;SoilDepth&quot;    &quot;W&quot;            &quot;SWE&quot;          &quot;Temp&quot;         &quot;Ksoil&quot;       
##  [6] &quot;Gsoil&quot;        &quot;dVec&quot;         &quot;sand&quot;         &quot;clay&quot;         &quot;om&quot;          
## [11] &quot;VG_alpha&quot;     &quot;VG_n&quot;         &quot;VG_theta_res&quot; &quot;VG_theta_sat&quot; &quot;Ksat&quot;        
## [16] &quot;Kdrain&quot;       &quot;macro&quot;        &quot;bd&quot;           &quot;rfc&quot;</code></pre>
<p>In addition to the physical soil description, this object contains soil parameters needed for soil water balance simulations.</p>
</div>
</div>
<div id="dynamic-simulation-functions" class="section level2">
<h2>Dynamic simulation functions</h2>
<div id="water-balance-and-plant-drought-stress" class="section level3">
<h3>Water balance and plant drought stress</h3>
<p>Eco-hydrological processes are fundamental for the simulation models included in the <code>medfate</code> package. In particular, the package allows the simulation of water balance of soils and plants within forest stands. Processes affecting soil water content include rainfall, canopy interception, infiltration and runoff, percolation and deep drainage, soil evaporation and plant transpiration. In <code>medfate</code>, the soil water balance of a forest is primarily used to predict drought stress for living plants in it. Soil water balance can be studied for a single forest stand using function <code>spwb()</code>. Function <code>spwb()</code> may be used to:</p>
<ol style="list-style-type: decimal">
<li>Monitor or forecast temporal variation in soil water content in particular stands (for example to estimate mushroom yield).</li>
<li>Monitor or forecast temporal variation of plant drought stress in particular stands (for example to anticipate mortality events).</li>
<li>Monitor or forecast temporal variation of fuel moisture in particular stands (for example to monitor wildfire risk).</li>
</ol>
</div>
<div id="forest-growth" class="section level3">
<h3>Forest growth</h3>
<p>Changes in leaf area and plant growth are key to evaluate the influence of climatic conditions on forest structure and function. Processes affecting annual changes leaf area and plant size are those involved water and carbon balances, as well as those affecting growth directly. Processes influencing plant water balance include those affecting soil water content, such as rainfall, canopy interception, infiltration and runoff, percolation and deep drainage, soil evaporation and plant transpiration. Carbon balance arises from the relationship between plant photosynthesis and respiration, although carbon reserves play a role in the availabity of carbon for growth. Water and carbon balances are coupled through the regulation of transpiration done by stomata. Plant growth is affected by the availability of carbon (source limitation), but also by temperature and water status (sink limitation).</p>
<p>Package <code>medfate</code> allows simulating plant growth of a set of cohorts (competing for light and water) in a single forest stand using function <code>growth()</code>. Leaf area of plants can be severely decreased by drought stress, causing an increase in dead leaf area and affecting carbon and water fluxes. Function <code>growth()</code> may be used to:</p>
<ol style="list-style-type: decimal">
<li>Monitor or forecast temporal variation in water fluxes and soil water content in particular stands (for example to estimate regulation ecosystem services) taking into account processes determining plant growth.</li>
<li>Monitor or forecast temporal variation of plant drought stress in particular stands(for example to anticipate mortality events) taking into account processes determining plant growth.</li>
<li>Monitor or forecast temporal variation of live fuel moisture and the amount of standing dead and live fuels in particular stands (for example to monitor wildfire risk).</li>
</ol>
</div>
<div id="sub-model-functions" class="section level3">
<h3>Sub-model functions</h3>
<p>Many of the functions included in <code>medfate</code> are internally called by simulation functions. Some of them are made available to the user, to facilitate understanding the different sub-models and to facilitate a more creative use of the package. Sub-model functions are grouped by <em>subject</em>, which is included in the name of the function. The different sub-model functions are (by subject):</p>
<ul>
<li><code>biophysics_*</code>: Physical and biophysical utility functions.</li>
<li><code>hydraulics_*</code>: Plant hydraulics.</li>
<li><code>hydrology_*</code>: Canopy and soil hydrology (rainfall interception, soil evaporation, soil infiltration).</li>
<li><code>light_*</code>: Light extinction and absortion.</li>
<li><code>moisture_*</code>: Live tissue moisture.</li>
<li><code>pheno_*</code>: Leaf phenology.</li>
<li><code>photo_*</code>: Leaf photosynthesis.</li>
<li><code>root_*</code>: Root distribution and conductance calculations.</li>
<li><code>soil_*</code>: Soil hydraulics and thermodynamics.</li>
<li><code>spwb_*</code>: Soil water balance parameter optimization/calibration routines.</li>
<li><code>transp_*</code>: Stomatal regulation and resulting transpiration/photosynthesis.</li>
</ul>
</div>
</div>
<div id="static-functions" class="section level2">
<h2>Static functions</h2>
<div id="plant-species-and-stand-attributes" class="section level3">
<h3>Plant, species and stand attributes</h3>
<p>Package <code>medfate</code> include a number of functions to examine properties of the plants conforming the <code>forest</code> object, summary functions at the stand level or vertical profiles of several physical properties:</p>
<ul>
<li><code>plant_*</code>: Cohort-level information (species name, id, leaf area, height…).</li>
<li><code>species_*</code>: Cohort-level attributes aggregated by species (e.g. basal area).</li>
<li><code>stand_*</code>: Stand-level attributes (e.g. basal area).</li>
<li><code>vprofile_*</code>: Vertical profiles (light, wind, fuel density, leaf area density).</li>
</ul>
</div>
<div id="fuel-properties-and-fire-hazard" class="section level3">
<h3>Fuel properties and fire hazard</h3>
<p>Vegetation functioning and dynamics have strong, but complex, effects on fire hazard. On one hand, growth and death of organs and individuals changes the amount of standing live and dead fuels, as well as downed dead fuels. On the other, day-to-day changes in soil and plant water content changes the physical properties of fuel, notably fuel moisture content. Package <code>medfate</code> provides functions to estimate fuel properties and potential fire behaviour in forest inventory plots. Specifically, function <code>fuel_stratification()</code> provides a stratification of the stand into understory and canopy strata; and <code>fuel_FCCS()</code> calculates fuel characteristics from a <code>forest</code> object following an adaptation of the protocols described for the Fuel Characteristics Classification System (Prichard et al. 2013). Function <code>fuel_cohortFineFMC()</code> allows obtaining daily fuel moisture content estimates corresponding to the water status of plants, as returned by function <code>spwb()</code>.</p>
<p>In FCCS, fuelbed is divided into six strata, including canopy, shrub, herbaceous vegetation, dead woody materials, leaf litter and ground fuels. All except ground fuels are considered here. The intensity of burning depends on several factors, including topography, wind conditions, fuel structure and its moisture content, which is determined from antecedent and current meteorological conditions. A modification of the Rothermel’s (1972) model is used in function <code>fire_FCCS()</code> to calculate the intensity of surface fire reaction and the rate of fire spread of surface fires assuming a steady-state fire. Both quantities are dependent on fuel characteristics, windspeed and direction, and topographic slope and aspect. Fuel and fire behaviour functions allow obtaining the following:</p>
<ol style="list-style-type: decimal">
<li>Fuel characteristics by stratum.</li>
<li>Surface fire behavior (i.e. reaction intensity, rate of spread, fireline intensity and flame length).</li>
<li>Crown fire behavior.</li>
<li>Fire potential ratings of surface fire behavior and crown fire behavior.</li>
</ol>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
